# Goroutine

事实上每一个Go程序至少有一个Goroutine：主Goroutine。当程序启动时，它会自动创建。

为了更好的理解Goroutine，先来了解一下线程与协程

## 线程（Thread）

- 线程属于进程

- 线程共享进程的内存地址空间

- 线程几乎不占有系统资源 通信问题:   进程相当于一个容器,而线程而是运行在容器里面的,因此对于容器内的东西,线程是共同享有的,因此线程间的通信可以直接通过全局变量进行通信,但是由此带来的例如多个线程读写同一个地址变量的时候则将带来不可预期的后果,因此这时候引入了各种锁的作用,例如互斥锁等。

同时多线程是不安全的,当一个线程崩溃了,会导致整个进程也崩溃了,即其他线程也挂了, 但多进程而不会,一个进程挂了,另一个进程依然照样运行

- 进程是系统分配资源的最小单位

- 线程是CPU调度的最小单位

- 由于默认进程内只有一个线程,所以多核CPU处理多进程就像是一个进程一个核心

## 协程

- 协程是属于线程的。协程程序是在线程里面跑，因此又称微线程和纤程等

- 协称没有线程上下文切换的消耗。协程的调度切换是用户(程序员)手动切换的,因此更加灵活,因此又叫用户空间线程.

- 原子操作性。由于协程是用户调度的，所以不会出现执行一半的代码片段被强制中断了，因此无需原子操作锁。

## 总结一下概念

- 进程： 一个程序对应一个独立程序空间

- 线程： 一个执行空间，一个进程可以有多个线程

## 概念

一个进程在启动的时候，会创建一个主线程，这个主线程结束的时候，程序进程也就终止了，所以一个进程至少有一个线程，这也是我们在main函数里，使用goroutine的时候，要让主线程等待的原因，因为主线程结束了，程序就终止了，那么就有可能会看不到goroutine的输出。

go语言中并发指的是让某个函数独立于其他函数运行的能力，一个goroutine就是一个独立的工作单元，Go的runtime（运行时）会在逻辑处理器上调度这些goroutine来运行，一个逻辑处理器绑定一个操作系统线程，所以说goroutine不是线程，它是一个协程，也是这个原因，它是由Go语言运行时本身的算法实现的。

- 逻辑处理器： 执行创建的goroutine，绑定一个线程

- 调度器： Go运行时中的，分配goroutine给不同的逻辑处理器

- 全局运行队列： 所有刚创建的goroutine都会放到这里

- 本地运行队列： 逻辑处理器的goroutine队列

当我们创建一个goroutine的后，会先存放在全局运行队列中，等待Go运行时的调度器进行调度，把他们分配给其中的一个逻辑处理器，并放到这个逻辑处理器对应的本地运行队列中，最终等着被逻辑处理器执行即可。