# Goroutine

事实上每一个Go程序至少有一个Goroutine：主Goroutine。当程序启动时，它会自动创建。

为了更好的理解Goroutine，先来了解一下线程与协程

## 线程（Thread）

- 线程属于进程

- 线程共享进程的内存地址空间

- 线程几乎不占有系统资源 通信问题:   进程相当于一个容器,而线程而是运行在容器里面的,因此对于容器内的东西,线程是共同享有的,因此线程间的通信可以直接通过全局变量进行通信,但是由此带来的例如多个线程读写同一个地址变量的时候则将带来不可预期的后果,因此这时候引入了各种锁的作用,例如互斥锁等。

同时多线程是不安全的,当一个线程崩溃了,会导致整个进程也崩溃了,即其他线程也挂了, 但多进程而不会,一个进程挂了,另一个进程依然照样运行

- 进程是系统分配资源的最小单位

- 线程是CPU调度的最小单位,线程的内存大小，怎么切分，有多大，等不等长都是由内核确定，并不由人工确定

- 由于默认进程内只有一个线程,所以多核CPU处理多进程就像是一个进程一个核心

## 协程(Coroutine)

- 协程是属于线程的。协程程序是在线程里面跑，因此又称微线程和纤程等

- 协称没有线程上下文切换的消耗。协程的调度切换是用户(程序员)手动切换的,因此更加灵活,因此又叫用户空间线程.

- 原子操作性。由于协程是用户调度的，所以不会出现执行一半的代码片段被强制中断了，因此无需原子操作锁。

### 对比线程协程的优势

- 协程内存消耗更小
  
  - 一个线程可以包含多个协程

  - 线程大约8MB的内存申请量，而协程大概2KB的内存申请量

- 上下文切换更快

  - 协程相对于线程少一道工序：线程申请内存，需要走过内核；协程申请内存，不需要走过内核

## 总结一下概念

- 进程： 一个程序对应一个独立程序空间

- 线程： 一个执行空间，一个进程可以有多个线程

## 概念

为什么使用Goroutine？

- 去掉了冗余的协程生命周期管理：协程创建、协程完成、协程重用

- 降低额外的延迟和开销：由于协程间频繁交互导致的

- 降低加锁/解锁的频率：降低一部分额外的开销

一个进程在启动的时候，会创建一个主线程，这个主线程结束的时候，程序进程也就终止了，所以一个进程至少有一个线程，这也是我们在main函数里，使用goroutine的时候，要让主线程等待的原因，因为主线程结束了，程序就终止了，那么就有可能会看不到goroutine的输出。

go语言中并发指的是让某个函数独立于其他函数运行的能力，一个goroutine就是一个独立的工作单元，Go的runtime（运行时）会在逻辑处理器上调度这些goroutine来运行，一个逻辑处理器绑定一个操作系统线程，所以说goroutine不是线程，它是一个协程，也是这个原因，它是由Go语言运行时本身的算法实现的。

- 逻辑处理器： 执行创建的goroutine，绑定一个线程

- 调度器： Go运行时中的，分配goroutine给不同的逻辑处理器

- 全局运行队列： 所有刚创建的goroutine都会放到这里

- 本地运行队列： 逻辑处理器的goroutine队列

当我们创建一个goroutine的后，会先存放在全局运行队列中，等待Go运行时的调度器进行调度，把他们分配给其中的一个逻辑处理器，并放到这个逻辑处理器对应的本地运行队列中，最终等着被逻辑处理器执行即可。